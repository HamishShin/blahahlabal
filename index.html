<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lights Out Graph Builder</title>
<style>
body {
  background: #111;
  color: white;
  font-family: sans-serif;
  text-align: center;
}
svg {
  background: #1a1a1a;
  border-radius: 10px;
  margin-top: 10px;
  cursor: crosshair;
}
circle { cursor: pointer; }
text {
  pointer-events: none;
  font-size: 14px;
  font-weight: bold;
  fill: grey;
  text-anchor: middle;
  dominant-baseline: middle;
}
button, select, input { margin: 5px; }
</style>
</head>
<body>

<h2>Lights Out Graph Builder</h2>

<select id="graphMode">
  <option value="grid">Grid</option>
  <option value="ring">Ring</option>
  <option value="custom">Custom</option>
</select>

<button id="modeBtn">Mode: PLAY</button>

<div id="customControls" style="margin:5px;">
  <button id="editToggleBtn">Start Editing</button>
  <button id="addNodeBtn">Add Node</button>
  <button id="addEdgeBtn">Add Edge</button>
</div>

<div id="presetControls" style="margin:5px"></div>

<div style="margin:5px;">
  <button id="randomBtn">Randomize</button>
  <button id="displayBtn">Display: COLORS</button>
  <button id="linearBtn">Linearize</button>
  <button id="undoBtn">Undo</button>
  <button id="saveBtn">Save</button>
  <button id="loadBtn">Load</button>
  States (k):
  <input type="number" id="stateCount" value="2" min="2" max="8">
  <!-- Solver buttons -->
  <button id="solveBtn">Solve</button>
  <button id="unsolveBtn">Unsolve</button>
</div>

<svg id="svg" width="600" height="600"></svg>

<script>
const svg=document.getElementById("svg");
const customControls=document.getElementById("customControls");
const presetControls=document.getElementById("presetControls");

const SIZE=600;
const R=12;
const COLORS=["#ff0000","#0000ff","#00ff00","#ffff00","#ff00ff","#00ffff","#ffffff","#ff8800"];

let nodes=[], labels=[];
let positions=[], originalPositions=[];
let edges=new Set();

let editMode=false;
let displayMode="colors";
let k=2;
let linear=false;
let graphType="grid";

/* ---------- CUSTOM MODE STATE (UNCHANGED) ---------- */
let customEditing=false;
let addingNode=false;
let addingEdge=false;
let edgeStart=null;

/* ---------- UNDO / SAVE ---------- */
let undoStack=[];
let savedState=null;

function saveStateSnapshot(){
  undoStack.push(nodes.map(n=>+n.dataset.state));
}

function loadStateSnapshot(snapshot){
  snapshot.forEach((s,i)=>{
    nodes[i].dataset.state=s;
    update(i);
  });
}

function saveGame(){
  savedState={ k, states:nodes.map(n=>+n.dataset.state) };
}

function loadGame(){
  if(!savedState) return;
  k=savedState.k;
  stateCount.value=k;
  savedState.states.forEach((s,i)=>{
    nodes[i].dataset.state=s;
    update(i);
  });
}

/* ---------- CORE ---------- */
function reset(){
  svg.innerHTML="";
  nodes=[]; labels=[];
  positions=[]; originalPositions=[];
  edges.clear();
  undoStack=[];
}

function adjacency(i){
  const a=[i];
  edges.forEach(e=>{
    const [x,y]=e.split("-").map(Number);
    if(x===i)a.push(y);
    if(y===i)a.push(x);
  });
  return a;
}

function createNode(x,y){
  const i=nodes.length;
  positions[i]={x,y};
  originalPositions[i]={x,y};

  const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx",x);
  c.setAttribute("cy",y);
  c.setAttribute("r",R);
  c.dataset.state="0";

  const t=document.createElementNS("http://www.w3.org/2000/svg","text");
  t.setAttribute("x",x);
  t.setAttribute("y",y);

  c.onclick=e=>{
    e.stopPropagation();

    /* ---- CUSTOM MODE (UNCHANGED) ---- */
    if(graphType==="custom" && customEditing && addingEdge){
      if(edgeStart===null){
        edgeStart=i;
        c.setAttribute("stroke","white");
        c.setAttribute("stroke-width","3");
      } else if(edgeStart!==i){
        edges.add([Math.min(edgeStart,i),Math.max(edgeStart,i)].join("-"));
        clearEdgeSelection();
        drawEdges();
      }
      return;
    }

    saveStateSnapshot();

    if(editMode){
      increment(i);
      return;
    }

    adjacency(i).forEach(increment);
  };

  svg.appendChild(c);
  svg.appendChild(t);
  nodes.push(c);
  labels.push(t);
  update(i);
  drawEdges();
}

function increment(i){
  nodes[i].dataset.state=(+nodes[i].dataset.state+1)%k;
  update(i);
}

function update(i){
  const s=+nodes[i].dataset.state;
  nodes[i].setAttribute("fill",COLORS[s%COLORS.length]);
  labels[i].textContent=s;
  labels[i].style.display=displayMode==="numbers"?"block":"none";
}

/* ---------- EDGES (RESTORED) ---------- */
function drawEdges(){
  const old=svg.querySelector("g");
  if(old) old.remove();
  const g=document.createElementNS("http://www.w3.org/2000/svg","g");

  edges.forEach(e=>{
    const [i,j]=e.split("-").map(Number);
    const p=positions[i], q=positions[j];

    if(!linear){
      const l=document.createElementNS("http://www.w3.org/2000/svg","line");
      l.setAttribute("x1",p.x);
      l.setAttribute("y1",p.y);
      l.setAttribute("x2",q.x);
      l.setAttribute("y2",q.y);
      l.setAttribute("stroke","#666");
      l.setAttribute("stroke-width","2");
      g.appendChild(l);
    } else {
      const d=Math.abs(i-j);
      const cx=SIZE/2+160+d*35;
      const cy=(p.y+q.y)/2;
      const path=document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d",`M ${p.x} ${p.y} Q ${cx} ${cy} ${q.x} ${q.y}`);
      path.setAttribute("fill","none");
      path.setAttribute("stroke","#888");
      path.setAttribute("stroke-width","2");
      g.appendChild(path);
    }
  });

  svg.prepend(g);
}

function clearEdgeSelection(){
  nodes.forEach(n=>n.removeAttribute("stroke"));
  edgeStart=null;
}

/* ---------- PRESET GRAPHS (RESTORED) ---------- */
function buildGrid(r,c){
  reset();
  const sx=80, sy=80;
  const ox=SIZE/2-(c-1)*sx/2;
  const oy=SIZE/2-(r-1)*sy/2;

  for(let i=0;i<r;i++)
    for(let j=0;j<c;j++)
      createNode(ox+j*sx,oy+i*sy);

  const n=r*c;
  for(let i=0;i<n;i++){
    const row=Math.floor(i/c), col=i%c;
    if(row<r-1) edges.add(`${i}-${i+c}`);
    if(col<c-1) edges.add(`${i}-${i+1}`);
  }
  drawEdges();
}

function buildRing(n){
  reset();
  const cx=SIZE/2, cy=SIZE/2, rad=200;
  for(let i=0;i<n;i++){
    const a=2*Math.PI*i/n;
    createNode(cx+Math.cos(a)*rad,cy+Math.sin(a)*rad);
  }
  for(let i=0;i<n;i++)
    edges.add(`${i}-${(i+1)%n}`);
  drawEdges();
}

/* ---------- LINEARIZATION (RESTORED) ---------- */
function animateLinearize(){
  const start=positions.map(p=>({...p}));
  const end=[];
  const x=SIZE/2, sp=SIZE/(nodes.length+1);

  if(!linear){
    for(let i=0;i<nodes.length;i++) end[i]={x,y:sp*(i+1)};
  } else {
    for(let i=0;i<nodes.length;i++) end[i]={...originalPositions[i]};
  }

  linear=!linear;
  const t0=performance.now(), dur=700;

  function step(t){
    const u=Math.min((t-t0)/dur,1);
    const s=u*u*(3-2*u);
    nodes.forEach((n,i)=>{
      const x=start[i].x+(end[i].x-start[i].x)*s;
      const y=start[i].y+(end[i].y-start[i].y)*s;
      positions[i]={x,y};
      n.setAttribute("cx",x);
      n.setAttribute("cy",y);
      labels[i].setAttribute("x",x);
      labels[i].setAttribute("y",y);
    });
    drawEdges();
    if(u<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* ---------- UI ---------- */
modeBtn.onclick=()=>{editMode=!editMode;modeBtn.textContent=`Mode: ${editMode?"EDIT":"PLAY"}`};
undoBtn.onclick=()=>{if(undoStack.length) loadStateSnapshot(undoStack.pop())};
saveBtn.onclick=saveGame;
loadBtn.onclick=loadGame;
randomBtn.onclick=()=>{saveStateSnapshot();nodes.forEach((_,i)=>{nodes[i].dataset.state=Math.floor(Math.random()*k);update(i)})};
displayBtn.onclick=()=>{displayMode=displayMode==="colors"?"numbers":"colors";displayBtn.textContent=`Display: ${displayMode.toUpperCase()}`;nodes.forEach((_,i)=>update(i))};
linearBtn.onclick=animateLinearize;

stateCount.onchange=e=>{
  k=Math.max(2,+e.target.value);
  nodes.forEach((n,i)=>{n.dataset.state%=k;update(i)});
};

/* ---------- CUSTOM MODE UI (UNCHANGED) ---------- */
editToggleBtn.onclick=()=>{
  customEditing=!customEditing;
  editToggleBtn.textContent=customEditing?"Stop Editing":"Start Editing";
  addingNode=customEditing;
  addingEdge=false;
  modeBtn.disabled=customEditing;
  if(!customEditing) clearEdgeSelection();
};

addNodeBtn.onclick=()=>{addingNode=true;addingEdge=false;clearEdgeSelection()};
addEdgeBtn.onclick=()=>{addingEdge=true;addingNode=false;clearEdgeSelection()};

graphMode.onchange=()=>{
  graphType=graphMode.value;
  presetControls.innerHTML="";
  customControls.style.display=graphType==="custom"?"block":"none";
  customEditing=false;
  editToggleBtn.textContent="Start Editing";
  modeBtn.disabled=false;

  if(graphType==="grid"){
    presetControls.innerHTML=`Rows <input id="r" value="5"> Cols <input id="c" value="5">`;
    r.oninput=c.oninput=()=>buildGrid(+r.value,+c.value);
    buildGrid(5,5);
  }
  if(graphType==="ring"){
    presetControls.innerHTML=`Nodes <input type="range" id="n" min="3" max="40" value="12"> <span id="nLabel">12</span>`;
    n.oninput=()=>{nLabel.textContent=n.value;buildRing(+n.value)};
    buildRing(12);
  }
  if(graphType==="custom"){
    reset();
  }
};

svg.onclick=e=>{
  if(graphType==="custom" && customEditing && addingNode){
    const r=svg.getBoundingClientRect();
    createNode(e.clientX-r.left,e.clientY-r.top);
  }
};

graphMode.onchange();

/* ---------- SOLVER ADDITION ---------- */

let solverActive = false;

function clearSolverMarks(){
  nodes.forEach(n=>{
    n.removeAttribute("stroke");
    n.removeAttribute("stroke-width");
  });
  solverActive = false;
}

function solvePuzzle(){
  clearSolverMarks();

  if(k !== 2){
    alert("Solver only supports k = 2");
    return;
  }

  const n = nodes.length;
  if(n === 0) return;

  const A = Array.from({length:n},()=>Array(n).fill(0));
  for(let i=0;i<n;i++){
    adjacency(i).forEach(j=>{
      A[j][i] = 1;
    });
  }

  const b = nodes.map(n => (1 - (+n.dataset.state)) & 1);
  const M = A.map((row,i)=>row.concat(b[i]));

  let row = 0;
  for(let col=0; col<n && row<n; col++){
    let pivot = row;
    while(pivot<n && M[pivot][col]===0) pivot++;
    if(pivot === n) continue;

    [M[row], M[pivot]] = [M[pivot], M[row]];

    for(let r=0;r<n;r++){
      if(r!==row && M[r][col]){
        for(let c=col;c<=n;c++){
          M[r][c] ^= M[row][c];
        }
      }
    }
    row++;
  }

  for(let r=row;r<n;r++){
    if(M[r][n]){
      alert("Puzzle is unsolvable");
      return;
    }
  }

  const solution = Array(n).fill(0);
  for(let i=0;i<row;i++){
    const lead = M[i].findIndex(v=>v===1);
    if(lead>=0) solution[lead] = M[i][n];
  }

  solution.forEach((v,i)=>{
    if(v){
      nodes[i].setAttribute("stroke","white");
      nodes[i].setAttribute("stroke-width","3");
    }
  });

  solverActive = true;
}

solveBtn.onclick = solvePuzzle;
unsolveBtn.onclick = clearSolverMarks;

</script>

</body>
</html>
